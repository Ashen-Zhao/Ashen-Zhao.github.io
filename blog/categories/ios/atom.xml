<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 啊神的技术博客]]></title>
  <link href="http://ashen-zhao.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ashen-zhao.github.io/"/>
  <updated>2016-01-18T21:13:00+08:00</updated>
  <id>http://ashen-zhao.github.io/</id>
  <author>
    <name><![CDATA[Ashen]]></name>
    <email><![CDATA[zhaoashen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 多语言版本的开发（三）]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/18/localized03/"/>
    <updated>2016-01-18T16:06:48+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/18/localized03</id>
    <content type="html"><![CDATA[<h3>写在前言</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多语言版本的开发（二）]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/15/localized02/"/>
    <updated>2016-01-15T05:13:56+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/15/localized02</id>
    <content type="html"><![CDATA[<h3>题记</h3>

<p>&emsp;&emsp;<a href="/blog/2016/01/14/localized01/">iOS 多语言版本的开发（一）</a> 中我们完成了让应用跟随系统语言进行切换，而用户自己却不能切换的功能，也基本上算是实现了多语言版本；可是，对于某些应用来说，实现跟随系统语言切换的同时， 也想要实现让用户自己选择应用语言版本的功能；针对这种情况，利用这篇文章来写写如何让用户自己切换应用语言版本；</p>

<h3>语言文件存在的形式</h3>

<p>想要实现用户自己手动切换语言版本，就先要了解语言文件在资源文件中存在的形式;</p>

<p><img src="/images/localized09.png" alt="多语言" /></p>

<p>如图中，不管是英语（en.lproj）、简体（zh-Hans.lproj）、还是繁体（zh-Hant.lproj）都是以<code>.lproj</code> 的文件夹形式存在, 所以当我们要切换语言的时候，其实也就是做到去取这些<code>.lproj</code> 文件夹中的<code>ASLocalized.strings</code>文件；</p>

<!--more-->


<p>
&emsp;到这里，原理应该懂了，接下来就是动手实现了；</p>

<h3>根据语言获取 ASLocalized.strings</h3>

<p>这时候，需要根据不同的<code>语言.lproj</code> 获取到对应的<code>ASLocalized.strings</code>语言文件, 从而让页面显示对应的语言内容;<br/>
这里暂且先根据English获取英语的语言文件，English 的.lproj存在的形式是<code>en.lproj</code></p>

<pre><code>
NSString *path = [[NSBundle mainBundle] pathForResource:@"en" ofType:@"lproj"];
NSString *showValue = [[NSBundle bundleWithPath:path] localizedStringForKey:@"showTxt" value:nil table:@"ASLocalized"];
NSLog(@"result: %@", showValue);
 </code></pre>


<p>输出结果：result: this is test text</p>

<p>以上代码，只是以English 为语言文件，是写死的，如果想要让用户自己手动改变，只需要替换掉 <code>[[NSBundle mainBundle] pathForResource:@"en" ofType:@"lproj"]</code> 中的<code>en</code> 为其他的语言标识就好了； 既然是用户手动切换，那就需要写代码去实现了；</p>

<p>到这里，有一个问题，<strong><em>如何让用户选择后一个语言后，即使程序退出后，下次进入依然保留呢</em></strong>， 既然需要保存数据，就要涉及到本地存储了，对于少量的保存我们可以使用<code>NSUserDefaults</code> 来操作，简单方便快捷；至于其他的存储方式四大基本对象的write方法，归档，sqllite，CoreData 需要的同学，可以自己去脑补，这里我不多介绍了；</p>

<h3>使用NSUserDefaults 记录选择的语言</h3>

<p>这里我简单写了个界面，作为辅助讲解</p>

<p><img src="http://ashen-zhao.github.io/images/localized10.png" alt="多语言" width="300" height="450"></p>

<pre><code>
- (IBAction)changeLanguage:(UIButton *)sender {
    
    switch (sender.tag) {
        case 101: { //简体
            [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hans" forKey:appLanguage];
        }
            break;
        case 102: { //繁体
            [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hant" forKey:appLanguage];
        }
            break;
        case 103: { //English
            [[NSUserDefaults standardUserDefaults] setObject:@"en" forKey:appLanguage];
        }
            break;
        default:
            break;
    }
}
</code></pre>


<p></p>

<p>以上方法，是图中三种语言的点击事件，分别将对应的语言标识，记录到<code>NSUserDefaults</code> 对应的 <code>appLanguage</code> key 中</p>

<p>既然重新选择了语言，就需要重新加载控件的内容，因为是Demo🐴，这里直接将给控件赋值写成一个方法，如下：</p>

<pre><code>
- (void)showLbl {
    NSString *lanType =[NSString stringWithFormat:@"%@", [[NSUserDefaults standardUserDefaults] objectForKey:@"appLanguage"]];
    
    NSString *path = [[NSBundle mainBundle] pathForResource:lanType ofType:@"lproj"];
    
    NSString *showValue = [[NSBundle bundleWithPath:path] localizedStringForKey:@"showTxt" value:nil table:@"ASLocalized"];
    NSLog(@"result: %@", showValue);
    self.lblShowTxt.text = showValue;
}

</code></pre>


<p></p>

<p>可将此方法在点击事件中调用下，即可；</p>

<p>Demo效果图：</p>

<p><img src="/images/localized11.gif" alt="多语言" /></p>

<h3>首次进入应用的考虑</h3>

<p>到这里，还没有完，这时我们需要考虑下，用户第一次进来时，该显示什么样的语言，是跟随系统，还是我们给一种默认的语言；</p>

<h4>1、给一种默认语言</h4>

<p>这种处理很简单，只需要在<code>didFinishLaunchingWithOptions</code> 方法中，进行判断本地是否记录了语言标识，如果没有给一种默认即可，代码如下：</p>

<pre>`
if (![[NSUserDefaults standardUserDefaults] objectForKey:appLanguage]) { 
     [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hans"    forKey:appLanguage];
}`</pre>


<p></p>

<h4>2、跟随系统语言</h4>

<p>这种处理相对来说，比较复杂写，首页需要获取系统的首选语言顺序，然后取第一个首选语言，其次，还要判断你要做的语言版本，首选语言组中存在与否；<br/>
获取首选语言：<code> NSArray  *languages = [NSLocale preferredLanguages];</code><br/>
获取第一个首选语言：<code> NSString *language = [languages objectAtIndex:0];</code></p>

<p>处理过程如下：</p>

<pre><code>
if (![[NSUserDefaults standardUserDefaults] objectForKey:appLanguage]) {
        NSArray  *languages = [NSLocale preferredLanguages];
        NSString *language = [languages objectAtIndex:0];
        if ([language hasPrefix:@"zh-Hans"]) {
            [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hans" forKey:appLanguage];
        } else if ([language hasPrefix:@"zh-TW"] || [language hasPrefix:@"zh-HK"] || [language hasPrefix:@"zh-Hant"]) {
            [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hant" forKey:appLanguage];
        } else if ([language hasPrefix:@"en"]) {
            [[NSUserDefaults standardUserDefaults] setObject:@"en" forKey:appLanguage];
        }else{
            [[NSUserDefaults standardUserDefaults] setObject:@"zh-Hans" forKey:appLanguage];
        }
    }
</code></pre>


<p></p>

<p>注：由于繁体又有台湾繁体和香港繁体之分，所以代码中也做出了相应的处理；</p>

<p>╮(╯▽╰)╭ 到了这里基本上算是完成了多语言版本的工作了，但是，但是，但是，这只是完成了项目起步期，项目中还不存在大量的中文字符串的情况；暂时先不考虑项目已经开发完成的情况，接下来先来优化下，我们刚刚写过的代码；<br/>
对于 <code>showLbl</code> 方法中的内容，可以定义成宏，以供项目中，任何地方需要多元化时的使用;</p>

<pre><code> 
 #define ASLocalizedString(key)  [NSString stringWithFormat:@"%@", [[NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:[NSString stringWithFormat:@"%@",[[NSUserDefaults standardUserDefaults] objectForKey:@"appLanguage"]] ofType:@"lproj"]] localizedStringForKey:(key) value:nil table:@"ASLocalized"]]
</code> </pre>


<p>
为了方便，我将<code>showLbl</code> 中取key对应的语言内容，封装进了一个带参数的宏中；</p>

<p>使用起来就很Easy了，只需要这样使用即可： <code>ASLocalizedString(@"showTxt")</code></p>

<p>我在github上，上传了本篇<a href="https://github.com/Ashen-Zhao/easyLocalized">Demo</a> 以供辅助参考；</p>

<p><a href="https://github.com/Ashen-Zhao/easyLocalized">查看Demo 点击这里</a></p>

<blockquote><h4>相关文章</h4>

<h4><a href="/blog/2016/01/14/localized01/">iOS 多语言版本的开发（一）</a></h4></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多语言版本的开发（一）]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/14/localized01/"/>
    <updated>2016-01-14T11:13:56+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/14/localized01</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>&emsp;多语言 &amp; 本地化，随你怎么叫，道理差不多；一个App 要想走出国门，只支持一种语言是不能够的，也是不可能的，多元化世界已经融入我们的生活，对于一些应用，开发多语言版本，已经是不可避免的，特别是旅游等方面的应用；国内也有很多App 已经接入多语言，例如：支付宝、微信、收留我（嘻嘻，做下广告）等；</p>

<h2>开发多语言，一般有两种情况</h2>

<p>1、App还没有开始写，这个时候创建一个多语言版本，很是容易，然后再写代码的时候稍微留意下哪里需要保持多语言就行了；<br/>
2、App已经上线了，而且之前没有任何的为开发多语言准备过，这时候Boss让开发多语言版本，这下你就苦逼了，想想项目中长长短短的中文字符串，没有上千也得上几百了吧，在想想一个一个替换，哎呀妈呀，那么多，想想都想死了，在想想还容易出错，哎呀妈呀，让我死了算了；</p>

<!--more-->


<p>别急，这次我就针对两种情况都讲解下；</p>

<h3>项目刚开始启动</h3>

<h4>1、新建一个项目（我就不多说了）</h4>

<h4>2、command + N 添加多语言文件，如下图</h4>

<p><img src="/images/localized01.png" alt="添加多语言文件" /></p>

<h4>3、添加多语言，如图</h4>

<p><img src="/images/localized02.png" alt="添加多语言" /></p>

<p>选择English  点击Localize<br/>
<img src="/images/localized03.png" alt="添加多语言" /></p>

<p><strong>到这里已经算是添加好了多语言文件，接下来就是添加多语言</strong></p>

<p>之前的XCode（具体到哪一个版本之前，不清楚了，我使用的是XCode7），是可以在如下图中直接点击➕号 ，添加多语言的</p>

<p><img src="/images/localized04.png" alt="添加多语言" /></p>

<p>现在需要进入项目的Project中的Localizations 中进行添加，如图</p>

<p><img src="/images/localized05.png" alt="添加多语言" /></p>

<p>我只添加了中文繁体，简体，以及英文，Demo使用的StoryBoard, 而添加多语言时，我没有选择为StoryBoard添加多语言版本的，毕竟是Demo🐴；但是不影响使用。</p>

<p><img src="/images/localized06.png" alt="添加多语言" /></p>

<p>到这里多语言文件中会出现如上图中的三个.strings 后缀的文件，这就是多语言对应的文件了，多语言添加的方式类似，字典 key=value 一一对应的关系，key 在三个.strings 中必须一致，而value 则分别对应不同的语言字体，即可；</p>

<h4>4、多语言文件的使用</h4>

<p>现分别在不同的语言文件中添加如下测试文本：</p>

<p><code>"showTxt"="this is test text";</code><br/>
<code>"showTxt"="这是一个测试的文本";</code><br/>
<code>"showTxt"="這是一個測試的文本";</code></p>

<p>说到使用，就要了解下<code>NSLocalizedString</code>  是什么</p>

<pre><code>
 #define NSLocalizedString(key, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@"" table:nil]
 #define NSLocalizedStringFromTable(key, tbl, comment) \
        [[NSBundle mainBundle] localizedStringForKey:(key) value:@"" table:(tbl)]
 #define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \
        [bundle localizedStringForKey:(key) value:@"" table:(tbl)]
 #define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \
        [bundle localizedStringForKey:(key) value:(val) table:(tbl)] </code></pre>


<p>其实就是宏，而宏定义的又是在资源文件中寻找对应的资源文件；<strong>在这里有个坑点</strong>，当你使用第一种实现多语言本地化，意味着你的多语言文件名字<strong>必须</strong>是<code>Localizable</code>,否则你的多语言实现，到最后显示的却只能是key； <br/>
第一种适合于，让应用跟随系统的语言版本进行切换，而用户却不能手动进行切换； 我们要实现的是既可以跟随系统，又可以用户自己切换，就不能使用这一个了，那就要使用第二种<code>NSLocalizedStringFromTable(key, tbl, comment)</code>&emsp;tbl这个参数，就是我们自己命名的多语言文件名称；</p>

<p>因此我们暂且这样使用（这样直接使用，会跟随系统语言）：</p>

<p><code>NSLocalizedStringFromTable(@"showTxt", @"ASLocalized", nil);</code></p>

<p>参数说明： 第一个参数，是多语言中的key, 第二个参数，是多语言文件的名字，第三个是对key的注释说明，一般为nil就可以了；</p>

<p>对于这样使用<code>NSLocalizedString("showTxt", nil)</code> ，切记多语言文件名<strong>必须</strong>是<code>Localizable</code>, 这里我们就不可以使用这种了；</p>

<h4>到这里，就可以实现简单的跟随系统语言的多语言版本了;</h4>

<p>效果图如下：</p>

<p><img src="/images/localized07.png" alt="添加多语言" /><br/>
<img src="/images/localized08.png" alt="添加多语言" /></p>

<blockquote><h4>相关文章</h4>

<h4><a href="/blog/2016/01/15/localized02/">iOS 多语言版本的开发（二）</a></h4></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView 与 原生系统的简单跳转交互]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/11/webview/"/>
    <updated>2016-01-11T10:15:09+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/11/webview</id>
    <content type="html"><![CDATA[<h3>简单介绍UIWebView</h3>

<p> 关于UIWebView这里我就不多介绍了，可以简单理解为一个在iOS 端显示网页的一个控件；</p>

<h3>UIWebView的使用</h3>

<p> 它既然也是view，当然就可以像其他view一样的创建，如下：</p>

<pre><code> UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, 320, 560)];

 webView.delegate = self;//先在此设置下代理，等下会实现其代理方法</code></pre>


<p> <!--more-->
 当然这是创建一个对象，想要加载一个网页还需要实现<code>loadRequest:</code>这个方法；这时你会发现该方法需要一个<code>NSURLRequest</code>类型的参数；那简单我们就来创建一个又如何；我们使用NSURLRequest的类方法<code>requestWithURL:</code>来创建；咦，又会发现这个类方法需要一个<code>NSURL</code>类型的参数；不管了，那就先创建NSURL对象吧；</p>

<pre><code>
 NSURL *url = [NSURL URLWithString:@"http://www.baidu.com"];

[webView loadRequest:[NSURLRequest requestWithURL:url];</code></pre>


<p> 切记后面一定要是一个可访问的网址；
 最后，因为它也是View，别忘记加到父视图上</p>

<pre><code>[self.view addSubview:webView];</code></pre>


<p>既然要实现与原生系统的交互，那就不得不实现它的代理方法</p>

<pre><code>-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
   NSString *urlStr = request.URL.absoluteString; //取出webView交互的url链接；
        //根据urlStr链接中的参数，去push到系统中的任何页面都可以的
       /*实现code
        .....
       */
      return YES;
}</code></pre>


<p> <b>附加说明</b>：urlStr是网页中，点击带有响应，传过来的网址，这个网址要看你服务端给的什么内容，针对内容去跳转到对象的页面(如：是一个头像的点击，则跳转到对应的用户信息，这是网址中，服务端就应该封装的有对应的用户的ID);
 该代理方法返回值是BOOL类型的，所以当你需要用webView来显示的时候，一定要返回YES; 至于跳转到App内其他页面就没有这么讲究了，YES or NO all ok; 建议返回NO, 以免出现web内与应用内两次跳转；
 如果服务端需要传参数进去（如：token) ，这是你就需要在创建<code>NSURL</code>对象时，将token封装进去</p>

<pre>[NSURL URLWithString:@"http://www.baidu.com?token=pzshgawegwegeugiwef93i24"]</pre>


<h6>自己在项目中就是这么实现的，如果有疑问或者有更好地方法，请与留言交流；</h6>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 常用加密方法]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/07/datasafety/"/>
    <updated>2016-01-07T17:30:15+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/07/datasafety</id>
    <content type="html"><![CDATA[<h3>为何要加密</h3>

<p>&emsp;为什么要加密，顾名思义，如果你不想让别人轻而易举的就拿到你的账号以及登录密码，如果你不想让别人获取你的敏感的数据(利益、聊天等数据),and so on; 不对数据进行加密，那就像你只穿个裤头，在到处跑，随时都可能走光；加密的重要性，我不多说，自己悟吧;<br/>
&emsp;iOS 开发中经常用到的几种加密方式：MD5、Base64、RSA、AES<br/>
&emsp;一般来说最常用的就是MD5和Base64：</p>

<blockquote><ol>
<li>MD5主要应用于普通请求、返回数据，进行数据完整性校验</li>
<li>Base64 主要用于防止数据明文传输</li>
<li>AES 一般用于登录加密</li>
<li>RSA 经常用于重要数据 以及敏感数据的加密</li>
</ol>
</blockquote>

<!--more-->


<h2>MD5</h2>

<pre><code>- (NSString *) stringFromMD5 {
if(self == nil || [self length] == 0) {        return nil;
}    const char *value = [self UTF8String];    unsigned char outputBuffer[CC_MD5_DIGEST_LENGTH];
CC_MD5(value, strlen(value), outputBuffer);
NSMutableString *outputString = [[NSMutableString alloc] initWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
for(NSInteger count = 0; count &lt; CC_MD5_DIGEST_LENGTH; count++){        [outputString appendFormat:@"%02x",outputBuffer[count]];
}       return outputString;
}
</code></pre>

<p>导入头文件：#import &lt;CommonCrypto/CommonDigest.h> <br/>
 该方法为NSString的分类方法</p>

<h2>Base64</h2>

<pre><code>static const char _base64EncodingTable[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const short _base64DecodingTable[256] = {
-2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -2, -1, -1, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, -2, -2, 63,
52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -2, -2, -2,
-2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, -2,
-2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2
};


+ (NSString *) encodeBase64WithString: (NSString *) strData {
NSData *objData = [strData dataUsingEncoding:NSUTF8StringEncoding];
const unsigned char * objRawData = [objData bytes];
char * objPointer;    char * strResult;    // Get the Raw Data length and ensure we actually have data
int intLength = [objData length];    if (intLength == 0) return nil;    // Setup the String-based Result placeholder and pointer within that placeholder
strResult = (char *)calloc(((intLength + 2) / 3) * 4, sizeof(char));    objPointer = strResult;    // Iterate through everything
while (intLength &gt; 2) { // keep going until we have less than 24 bits        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[((objRawData[1] &amp; 0x0f) &lt;&lt; 2) + (objRawData[2] &gt;&gt; 6)]; *objPointer++ = _base64EncodingTable[objRawData[2] &amp; 0x3f];        // we just handled 3 octets (24 bits) of data
    objRawData += 3;        intLength -= 3;    }    // now deal with the tail end of things    if (intLength != 0) {        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        if (intLength &gt; 1) {            *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[(objRawData[1] &amp; 0x0f) &lt;&lt; 2];            *objPointer++ = '=';        } else {            *objPointer++ = _base64EncodingTable[(objRawData[0] &amp; 0x03) &lt;&lt; 4];            *objPointer++ = '=';            *objPointer++ = '=';        }    }    // Terminate the string-based result
*objPointer = '\0';    NSString *rstStr = [NSString stringWithCString:strResult encoding:NSASCIIStringEncoding]; free(objPointer);    return rstStr;    }


+ (NSData *)decodeBase64WithString:(NSString *)strBase64 {
const char *objPointer = [strBase64 cStringUsingEncoding:NSASCIIStringEncoding];
size_t intLength = strlen(objPointer);
int intCurrent;
int i = 0, j = 0, k;

unsigned char *objResult = calloc(intLength, sizeof(unsigned char));

// Run through the whole string, converting as we go
while ( ((intCurrent = *objPointer++) != '\0') &amp;&amp; (intLength-- &gt; 0) ) {
    if (intCurrent == '=') {
        if (*objPointer != '=' &amp;&amp; ((i % 4) == 1)) {// || (intLength &gt; 0)) {
            // the padding character is invalid at this point -- so this entire string is invalid
            free(objResult);
            return nil;
        }
        continue;
    }

    intCurrent = _base64DecodingTable[intCurrent];
    if (intCurrent == -1) {
        // we're at a whitespace -- simply skip over
        continue;
    } else if (intCurrent == -2) {
        // we're at an invalid character
        free(objResult);
        return nil;
    }

    switch (i % 4) {
        case 0:
            objResult[j] = intCurrent &lt;&lt; 2;
            break;

        case 1:
            objResult[j++] |= intCurrent &gt;&gt; 4;
            objResult[j] = (intCurrent &amp; 0x0f) &lt;&lt; 4;
            break;

        case 2:
            objResult[j++] |= intCurrent &gt;&gt;2;
            objResult[j] = (intCurrent &amp; 0x03) &lt;&lt; 6;
            break;

        case 3:
            objResult[j++] |= intCurrent;
            break;
    }
    i++;
}

// mop things up if we ended on a boundary
k = j;
if (intCurrent == '=') {
    switch (i % 4) {
        case 1:
            // Invalid state
            free(objResult);
            return nil;

        case 2:
            k++;
            // flow through
        case 3:
            objResult[k] = 0;
    }
}

// Cleanup and setup the return NSData
NSData * objData = [[NSData alloc] initWithBytes:objResult length:j];
free(objResult);
return objData;
}
</code></pre>

<h2>RSA</h2>

<p>RSA: 比较复杂，这有一篇博客可以参考<a href="http://blog.iamzsx.me/show.html?id=155002">iOS下的RSA加密算法</a></p>

<h2>AES</h2>

<p>对于AES 这也有一个不错的博客<a href="http://www.tuicool.com/articles/UVRjmyN">AES加密算法</a></p>
]]></content>
  </entry>
  
</feed>
