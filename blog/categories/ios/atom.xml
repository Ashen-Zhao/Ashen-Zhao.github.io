<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 啊神的技术博客]]></title>
  <link href="http://ashen-zhao.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ashen-zhao.github.io/"/>
  <updated>2016-01-07T18:26:32+08:00</updated>
  <id>http://ashen-zhao.github.io/</id>
  <author>
    <name><![CDATA[A-shen]]></name>
    <email><![CDATA[zhaoashen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 常用加密方法]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/07/datasafety/"/>
    <updated>2016-01-07T17:30:15+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/07/datasafety</id>
    <content type="html"><![CDATA[<h1>为何要加密</h1>

<p>&emsp;为什么要加密，顾名思义，如果你不想让别人轻而易举的就拿到你的账号以及登录密码，如果你不想让别人获取你的敏感的数据(利益、聊天等数据),and so on; 不对数据进行加密，那就像你只穿个裤头，在到处跑，随时都可能走光；加密的重要性，我不多说，自己悟吧;<br/>
&emsp;iOS 开发中经常用到的几种加密方式：MD5、Base64、RSA、AES<br/>
&emsp;一般来说最常用的就是MD5和Base64：</p>

<ol>
<li>MD5主要应用于普通请求、返回数据，进行数据完整性校验</li>
<li>Base64 主要用于防止数据明文传输</li>
<li>AES 一般用于登录加密</li>
<li>RSA 经常用于重要数据 以及敏感数据的加密</li>
</ol>


<!--more-->


<h1>MD5</h1>

<pre><code>- (NSString *) stringFromMD5 {
if(self == nil || [self length] == 0) {        return nil;
}    const char *value = [self UTF8String];    unsigned char outputBuffer[CC_MD5_DIGEST_LENGTH];
CC_MD5(value, strlen(value), outputBuffer);
NSMutableString *outputString = [[NSMutableString alloc] initWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
for(NSInteger count = 0; count &lt; CC_MD5_DIGEST_LENGTH; count++){        [outputString appendFormat:@"%02x",outputBuffer[count]];
}    return outputString;
</code></pre>

<p>}
导入头文件：#import &lt;CommonCrypto/CommonDigest.h></p>

<h1>Base64</h1>

<pre><code>static const char _base64EncodingTable[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const short _base64DecodingTable[256] = {
-2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -2, -1, -1, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, -2, -2, 63,
52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -2, -2, -2,
-2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, -2,
-2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2
};


+ (NSString *) encodeBase64WithString: (NSString *) strData {
NSData *objData = [strData dataUsingEncoding:NSUTF8StringEncoding];
const unsigned char * objRawData = [objData bytes];
char * objPointer;    char * strResult;    // Get the Raw Data length and ensure we actually have data
int intLength = [objData length];    if (intLength == 0) return nil;    // Setup the String-based Result placeholder and pointer within that placeholder
strResult = (char *)calloc(((intLength + 2) / 3) * 4, sizeof(char));    objPointer = strResult;    // Iterate through everything
while (intLength &gt; 2) { // keep going until we have less than 24 bits        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[((objRawData[1] &amp; 0x0f) &lt;&lt; 2) + (objRawData[2] &gt;&gt; 6)]; *objPointer++ = _base64EncodingTable[objRawData[2] &amp; 0x3f];        // we just handled 3 octets (24 bits) of data
    objRawData += 3;        intLength -= 3;    }    // now deal with the tail end of things    if (intLength != 0) {        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        if (intLength &gt; 1) {            *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[(objRawData[1] &amp; 0x0f) &lt;&lt; 2];            *objPointer++ = '=';        } else {            *objPointer++ = _base64EncodingTable[(objRawData[0] &amp; 0x03) &lt;&lt; 4];            *objPointer++ = '=';            *objPointer++ = '=';        }    }    // Terminate the string-based result
*objPointer = '\0';    NSString *rstStr = [NSString stringWithCString:strResult encoding:NSASCIIStringEncoding]; free(objPointer);    return rstStr;    }


+ (NSData *)decodeBase64WithString:(NSString *)strBase64 {
const char *objPointer = [strBase64 cStringUsingEncoding:NSASCIIStringEncoding];
size_t intLength = strlen(objPointer);
int intCurrent;
int i = 0, j = 0, k;

unsigned char *objResult = calloc(intLength, sizeof(unsigned char));

// Run through the whole string, converting as we go
while ( ((intCurrent = *objPointer++) != '\0') &amp;&amp; (intLength-- &gt; 0) ) {
    if (intCurrent == '=') {
        if (*objPointer != '=' &amp;&amp; ((i % 4) == 1)) {// || (intLength &gt; 0)) {
            // the padding character is invalid at this point -- so this entire string is invalid
            free(objResult);
            return nil;
        }
        continue;
    }

    intCurrent = _base64DecodingTable[intCurrent];
    if (intCurrent == -1) {
        // we're at a whitespace -- simply skip over
        continue;
    } else if (intCurrent == -2) {
        // we're at an invalid character
        free(objResult);
        return nil;
    }

    switch (i % 4) {
        case 0:
            objResult[j] = intCurrent &lt;&lt; 2;
            break;

        case 1:
            objResult[j++] |= intCurrent &gt;&gt; 4;
            objResult[j] = (intCurrent &amp; 0x0f) &lt;&lt; 4;
            break;

        case 2:
            objResult[j++] |= intCurrent &gt;&gt;2;
            objResult[j] = (intCurrent &amp; 0x03) &lt;&lt; 6;
            break;

        case 3:
            objResult[j++] |= intCurrent;
            break;
    }
    i++;
}

// mop things up if we ended on a boundary
k = j;
if (intCurrent == '=') {
    switch (i % 4) {
        case 1:
            // Invalid state
            free(objResult);
            return nil;

        case 2:
            k++;
            // flow through
        case 3:
            objResult[k] = 0;
    }
}

// Cleanup and setup the return NSData
NSData * objData = [[NSData alloc] initWithBytes:objResult length:j];
free(objResult);
return objData;
}
</code></pre>

<h1>未完待续</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从工程中删除Cocoapods]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/05/delcocopods/"/>
    <updated>2016-01-05T17:16:42+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/05/delcocopods</id>
    <content type="html"><![CDATA[<p>&emsp;会有这么一种情况，因为需要改动的第三方比较多，不想使用cocoapods管理第三方，这时候，对于已经使用cocoapods的情况，需要进行删除处理，就可以按照以下步骤进行：</p>

<ol>
<li><p>删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹</p></li>
<li><p>删除xcworkspace文件</p></li>
<li><p>使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用</p></li>
<li><p>在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources, 可能还会有Embed Pods Frameworks也删了，总之带有Pods全删了</p></li>
</ol>


<!--more-->


<p><img src="/images/delcocopods.png" alt="删除图" /></p>

<p><strong>注意</strong>:如果将cocoapods集成到工程中后不小心修改或删除了其相关文件导致无法便以通过例如：不小心把</p>

<p>Pods.xcconfig给删除了然后出现diff: /../Podfile.lock: No such file or directory，用上面的方法删除cocoapods后，</p>

<p>再重新$sudo pod install一下就好了。</p>

<p>如果编译的时候出现权限问题，对工程文件夹$sudo chmod 777 path-to-project-folder/*</p>

<p>$sudo chown 777 path-to-project-folder/*</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多样式UILabel]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/04/colorfullabel/"/>
    <updated>2016-01-04T16:22:19+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/04/colorfullabel</id>
    <content type="html"><![CDATA[<p> 有时候产品经理说，能把一句话显示多种颜色、多种字体吗？ 灵光一闪，弄多个UILabel来显示不就行了，我只能说可以，也只能说这法有点笨。于是我坚决不用这种方法，苦思冥想，终于有了眉目。先配张图来显摆显摆，其实很容易实现，我也就不啰嗦了，看招：
 <!--more-->
<img src="http://upload-images.jianshu.io/upload_images/1168293-0ce90e359fcc8c76.png" alt="多样式UILabel" /></p>

<h5>由于很简单，不喜请喷我。</h5>

<p>ok, 上代码，一看也就是一个方法：</p>

<pre><code>
-(void)txtArr:(NSArray *)txtArr colorArr:(NSArray *)colorArr fontArr:(NSArray *)fontArr {

    NSInteger okCount = 0;
    okCount = txtArr.count < colorArr.count ? txtArr.count : colorArr.count;
    okCount = okCount < fontArr.count ? okCount : fontArr.count;

    NSMutableString *txt = [NSMutableString string];
    for (NSString *str in txtArr) {
        [txt appendString:str];
    }
    NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:txt];
    NSInteger startLoc = 0;
    for (int i = 0; i < okCount; i++) {
        [str addAttributes:@{NSForegroundColorAttributeName:colorArr[i], NSFontAttributeName:[UIFont systemFontOfSize:[fontArr[i] integerValue]]} range:NSMakeRange(startLoc, [txtArr[i] length])];
        startLoc += [txtArr[i] length];
    }
    self.attributedText = str;
}
</code></pre>


<h5>参数说明基本都是见明知意（大人，请允许我自恋吧）</h5>

<ol>
<li>txtArr: 传入的文本数组（对象是字符串）</li>
<li>colorArr: 颜色数组  （对象是UIColor）</li>
<li>fontArr: 字体数组  (对象是字符串如：@&ldquo;18&rdquo; 号字体)</li>
</ol>


<h5>使用方法，写给新手哦，老手请过滤吧，不然你又该喷我了</h5>

<p>我还是以代码使用为主</p>

<pre><code>
NSArray *a = [NSArray arrayWithObjects:@"瞅啥瞅", @"我不就是", @"多样式label么，哈哈", nil];

    NSArray *b = [NSArray arrayWithObjects:[UIColor redColor], [UIColor blackColor], [UIColor blueColor], nil];
    NSArray *c = [NSArray arrayWithObjects:@"19", @"13", @"17", nil];
    [self.multiLabel txtArr:a colorArr:b fontArr:c];
</code></pre>


<p>哎，对了，我将此方法写成了UILabel的分类了，所以这么使用没什么不妥；至于分类，不懂得，去google吧，没翻墙的还是百度吧；</p>

<p><a href="https://github.com/Ashen-Zhao/multiLabel">Demo下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 如何随意的push来pop去]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/04/any-push-pop/"/>
    <updated>2016-01-04T11:08:00+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/04/any-push-pop</id>
    <content type="html"><![CDATA[<h2>iOS 导航控制器如何随意push和pop</h2>

<hr />

<p>第一次开始写技术文章，请同学们多多关照，有错的地方请给我指出，大家学习一起成长，好了，我就废话不多少了；</p>

<hr />

<h4>主题思想：如A、B、C、D 四个视图控制器</h4>

<p>想要在 A push B 后， B 在push 到 D ，然后从 D pop 到 C ,在从 C pop 的A</p>

<hr />

<h4>解决方法如下：</h4>

<p>1.假如此时在 A 控制器下，想要到 push 到 B， 可以这样写</p>

<pre><code> [self.navigationController pushViewController: B :YES];
</code></pre>

<p> <!--more-->
这时 <code>self.navigationController.viewControllers</code> 中按顺序含有 [A，B]</p>

<p>2.此时已经到 B 控制器下了， 接下来是 push 到 D, 可以这样写</p>

<pre><code> [self.navigationController pushViewController: D :YES];
</code></pre>

<p>这时 <code>self.navigationController.viewControllers</code> 中按顺序含有 [A，B，D]</p>

<p>接下来<strong>很重要，很重要，很重要</strong>：</p>

<p>如何想从 D pop 到 C, 看数组[A，B，D] 中压根就没有C 该如何pop 到C呢？</p>

<p>这时就需要对这个数组进行修改，将C 加入进去</p>

<p><strong>于是 你会如下写：</strong></p>

<pre><code>[self.navigationController.viewControllers addObject:C]; 
</code></pre>

<p>发现报错，这是因为<code>self.navigationController.viewControllers</code> 是不可变数组，没办法了，我们只好转换一下了：</p>

<pre><code>NSMutableArray*tempMarr =[NSMutableArrayarrayWithArray:self.navigationController.viewControllers];
</code></pre>

<p>此时再加入C 就容易多了，咦，聪明的你会发现从 D pop C 不能直接将 C直接 addObject;</p>

<p><strong>当然，我会这样做：</strong></p>

<pre><code>[tempMarr insertObject:C atIndex:tempMarr.count- 2];
</code></pre>

<p>这时候 <code>tempMarr</code> 是这样的 [A，B，C，D],  可是 要想 从 C pop 到 A ,数组中就不能有 B</p>

<p>就需要 将<code>tempMarr</code> 变成 [A，C，D] ，至于怎么变，你比我懂得多，</p>

<p>懂得思考的同学会发现 这时的<code>self.navigationController.viewControllers</code> 依然是 [A，B，D]， 不用急，不用怕<code>navigationController</code> 有这样一个方法, 可以搞定，如下：</p>

<pre><code>[self.navigationController setViewControllers:tempMarr animated:YES];
</code></pre>

<p>有的同学会说，这不是直接把 B 替换 成 C 吗</p>

<p>看上去是这样，可是跳转的时机，时机，时机重要的事情说三遍，还有视图的切换，切换，切换</p>

<p>此时还在 B 控制器中，这些处理过程都是在 B 中处理的 ， 也必须是 B 执行了 push 到 D 方法后，也就是说</p>

<pre><code>[self.navigationController pushViewController:D animated:YES];
</code></pre>

<p> 之后 进行的 数组处理；</p>

<h4>附加代码：</h4>

<p>在B 控制器中处理：</p>

<pre><code>-(void)pushTest {

    [self.navigationController pushViewController:D animated:YES];

NSMutableArray*tempMarr =[NSMutableArrayarrayWithArray:self.navigationController.viewControllers];

[tempMarr insertObject:C atIndex:tempMarr.count- 2];

[tempMarr removeObject:self]; //此时 的self 就是指 B ,因为在 B 中呢

[self.navigationController setViewControllers:tempMarr animated:YES];

}
</code></pre>

<p><a href="https://github.com/Ashen-Zhao/anypushpop">Demo下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 只需几步实现生日选择器]]></title>
    <link href="http://ashen-zhao.github.io/blog/2015/12/29/birthSelector/"/>
    <updated>2015-12-29T15:19:49+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2015/12/29/birthSelector</id>
    <content type="html"><![CDATA[<p>  项目开发中难免会遇到让用户填写出生年月的时候，本章来介绍一下我自己写的生日选择器的<a href="https://github.com/Ashen-Zhao/ASBirthSheet">ASBirthSheet</a>;
  <!--more-->
  </br>
大致就是这个样子<img src="http://ashen-zhao.github.io/images/birthsrceenshot.png" alt="示例图" />
  我对生日选择器页面进行了简单的封装，算上.h文件只有两个文件，使用起来很简单；</p>

<h4>以下是对.h文件中的说明</h4>

<pre><code>
@property (nonatomic, copy) void(^GetSelectDate)(NSString *dateStr);

@property (nonatomic, strong) NSString * selectDate;
</code></pre>


<p><code>GetSelectDate</code>是一个Block回调，是在选择完日期后确认后，就会触发，它返回一个日期格式为<code>2015-12-08</code>的字符串；
<code>selectDate</code>是设置选中时的日期格式也需要是<code>2015-12-08</code>才能匹配；</p>

<h4>以下是使用方法：</h4>

<pre><code>
-(void)chooseBirthdayAction{

    ASBirthSelectSheet *datesheet = [[ASBirthSelectSheet alloc] initWithFrame:self.view.bounds];
    datesheet.selectDate = @"2015-12-08";
    datesheet.GetSelectDate = ^(NSString *dateStr) {
        NSLog(@"ok Date:%@", dateStr);
    };
    [self.view addSubview:datesheet];
}
</code></pre>


<p>使用起来很容易就这么几步，就可以实现一个简单的生日选择器；
由于只是使用，并没有对其进行很好地封装，如果你感兴趣，可以封装的更好点，来共同交流下；
附：
<a href="https://github.com/Ashen-Zhao/ASBirthSheet">Demo下载地址</a></p>
]]></content>
  </entry>
  
</feed>
