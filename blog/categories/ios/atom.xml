<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 啊神的技术博客]]></title>
  <link href="http://ashen-zhao.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://ashen-zhao.github.io/"/>
  <updated>2016-01-12T11:01:02+08:00</updated>
  <id>http://ashen-zhao.github.io/</id>
  <author>
    <name><![CDATA[Ashen]]></name>
    <email><![CDATA[zhaoashen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UIWebView 与 原生系统的简单跳转交互]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/11/webview/"/>
    <updated>2016-01-11T10:15:09+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/11/webview</id>
    <content type="html"><![CDATA[<h3>简单介绍UIWebView</h3>

<p> 关于UIWebView这里我就不多介绍了，可以简单理解为一个在iOS 端显示网页的一个控件；</p>

<h3>UIWebView的使用</h3>

<p> 它既然也是view，当然就可以像其他view一样的创建，如下：</p>

<pre><code> UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, 320, 560)];

 webView.delegate = self;//先在此设置下代理，等下会实现其代理方法</code></pre>


<p> <!--more-->
 当然这是创建一个对象，想要加载一个网页还需要实现<code>loadRequest:</code>这个方法；这时你会发现该方法需要一个<code>NSURLRequest</code>类型的参数；那简单我们就来创建一个又如何；我们使用NSURLRequest的类方法<code>requestWithURL:</code>来创建；咦，又会发现这个类方法需要一个<code>NSURL</code>类型的参数；不管了，那就先创建NSURL对象吧；</p>

<pre><code>
 NSURL *url = [NSURL URLWithString:@"http://www.baidu.com"];

[webView loadRequest:[NSURLRequest requestWithURL:url];</code></pre>


<p> 切记后面一定要是一个可访问的网址；
 最后，因为它也是View，别忘记加到父视图上</p>

<pre><code>[self.view addSubview:webView];</code></pre>


<p>既然要实现与原生系统的交互，那就不得不实现它的代理方法</p>

<pre><code>-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
   NSString *urlStr = request.URL.absoluteString; //取出webView交互的url链接；
        //根据urlStr链接中的参数，去push到系统中的任何页面都可以的
       /*实现code
        .....
       */
      return YES;
}</code></pre>


<p> <b>附加说明</b>：urlStr是网页中，点击带有响应，传过来的网址，这个网址要看你服务端给的什么内容，针对内容去跳转到对象的页面(如：是一个头像的点击，则跳转到对应的用户信息，这是网址中，服务端就应该封装的有对应的用户的ID);
 该代理方法返回值是BOOL类型的，所以当你需要用webView来显示的时候，一定要返回YES; 至于跳转到App内其他页面就没有这么讲究了，YES or NO all ok; 建议返回NO, 以免出现web内与应用内两次跳转；
 如果服务端需要传参数进去（如：token) ，这是你就需要在创建<code>NSURL</code>对象时，将token封装进去</p>

<pre>[NSURL URLWithString:@"http://www.baidu.com?token=pzshgawegwegeugiwef93i24"]</pre>


<h6>自己在项目中就是这么实现的，如果有疑问或者有更好地方法，请与留言交流；</h6>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 常用加密方法]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/07/datasafety/"/>
    <updated>2016-01-07T17:30:15+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/07/datasafety</id>
    <content type="html"><![CDATA[<h3>为何要加密</h3>

<p>&emsp;为什么要加密，顾名思义，如果你不想让别人轻而易举的就拿到你的账号以及登录密码，如果你不想让别人获取你的敏感的数据(利益、聊天等数据),and so on; 不对数据进行加密，那就像你只穿个裤头，在到处跑，随时都可能走光；加密的重要性，我不多说，自己悟吧;<br/>
&emsp;iOS 开发中经常用到的几种加密方式：MD5、Base64、RSA、AES<br/>
&emsp;一般来说最常用的就是MD5和Base64：</p>

<blockquote><ol>
<li>MD5主要应用于普通请求、返回数据，进行数据完整性校验</li>
<li>Base64 主要用于防止数据明文传输</li>
<li>AES 一般用于登录加密</li>
<li>RSA 经常用于重要数据 以及敏感数据的加密</li>
</ol>
</blockquote>

<!--more-->


<h2>MD5</h2>

<pre><code>- (NSString *) stringFromMD5 {
if(self == nil || [self length] == 0) {        return nil;
}    const char *value = [self UTF8String];    unsigned char outputBuffer[CC_MD5_DIGEST_LENGTH];
CC_MD5(value, strlen(value), outputBuffer);
NSMutableString *outputString = [[NSMutableString alloc] initWithCapacity:CC_MD5_DIGEST_LENGTH * 2];
for(NSInteger count = 0; count &lt; CC_MD5_DIGEST_LENGTH; count++){        [outputString appendFormat:@"%02x",outputBuffer[count]];
}       return outputString;
}
</code></pre>

<p>导入头文件：#import &lt;CommonCrypto/CommonDigest.h> <br/>
 该方法为NSString的分类方法</p>

<h2>Base64</h2>

<pre><code>static const char _base64EncodingTable[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const short _base64DecodingTable[256] = {
-2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -2, -1, -1, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, -2, -2, 63,
52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -2, -2, -2,
-2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, -2,
-2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2
};


+ (NSString *) encodeBase64WithString: (NSString *) strData {
NSData *objData = [strData dataUsingEncoding:NSUTF8StringEncoding];
const unsigned char * objRawData = [objData bytes];
char * objPointer;    char * strResult;    // Get the Raw Data length and ensure we actually have data
int intLength = [objData length];    if (intLength == 0) return nil;    // Setup the String-based Result placeholder and pointer within that placeholder
strResult = (char *)calloc(((intLength + 2) / 3) * 4, sizeof(char));    objPointer = strResult;    // Iterate through everything
while (intLength &gt; 2) { // keep going until we have less than 24 bits        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[((objRawData[1] &amp; 0x0f) &lt;&lt; 2) + (objRawData[2] &gt;&gt; 6)]; *objPointer++ = _base64EncodingTable[objRawData[2] &amp; 0x3f];        // we just handled 3 octets (24 bits) of data
    objRawData += 3;        intLength -= 3;    }    // now deal with the tail end of things    if (intLength != 0) {        *objPointer++ = _base64EncodingTable[objRawData[0] &gt;&gt; 2];        if (intLength &gt; 1) {            *objPointer++ = _base64EncodingTable[((objRawData[0] &amp; 0x03) &lt;&lt; 4) + (objRawData[1] &gt;&gt; 4)]; *objPointer++ = _base64EncodingTable[(objRawData[1] &amp; 0x0f) &lt;&lt; 2];            *objPointer++ = '=';        } else {            *objPointer++ = _base64EncodingTable[(objRawData[0] &amp; 0x03) &lt;&lt; 4];            *objPointer++ = '=';            *objPointer++ = '=';        }    }    // Terminate the string-based result
*objPointer = '\0';    NSString *rstStr = [NSString stringWithCString:strResult encoding:NSASCIIStringEncoding]; free(objPointer);    return rstStr;    }


+ (NSData *)decodeBase64WithString:(NSString *)strBase64 {
const char *objPointer = [strBase64 cStringUsingEncoding:NSASCIIStringEncoding];
size_t intLength = strlen(objPointer);
int intCurrent;
int i = 0, j = 0, k;

unsigned char *objResult = calloc(intLength, sizeof(unsigned char));

// Run through the whole string, converting as we go
while ( ((intCurrent = *objPointer++) != '\0') &amp;&amp; (intLength-- &gt; 0) ) {
    if (intCurrent == '=') {
        if (*objPointer != '=' &amp;&amp; ((i % 4) == 1)) {// || (intLength &gt; 0)) {
            // the padding character is invalid at this point -- so this entire string is invalid
            free(objResult);
            return nil;
        }
        continue;
    }

    intCurrent = _base64DecodingTable[intCurrent];
    if (intCurrent == -1) {
        // we're at a whitespace -- simply skip over
        continue;
    } else if (intCurrent == -2) {
        // we're at an invalid character
        free(objResult);
        return nil;
    }

    switch (i % 4) {
        case 0:
            objResult[j] = intCurrent &lt;&lt; 2;
            break;

        case 1:
            objResult[j++] |= intCurrent &gt;&gt; 4;
            objResult[j] = (intCurrent &amp; 0x0f) &lt;&lt; 4;
            break;

        case 2:
            objResult[j++] |= intCurrent &gt;&gt;2;
            objResult[j] = (intCurrent &amp; 0x03) &lt;&lt; 6;
            break;

        case 3:
            objResult[j++] |= intCurrent;
            break;
    }
    i++;
}

// mop things up if we ended on a boundary
k = j;
if (intCurrent == '=') {
    switch (i % 4) {
        case 1:
            // Invalid state
            free(objResult);
            return nil;

        case 2:
            k++;
            // flow through
        case 3:
            objResult[k] = 0;
    }
}

// Cleanup and setup the return NSData
NSData * objData = [[NSData alloc] initWithBytes:objResult length:j];
free(objResult);
return objData;
}
</code></pre>

<h2>RSA</h2>

<p>RSA: 比较复杂，这有一篇博客可以参考<a href="http://blog.iamzsx.me/show.html?id=155002">iOS下的RSA加密算法</a></p>

<h2>AES</h2>

<p>对于AES 这也有一个不错的博客<a href="http://www.tuicool.com/articles/UVRjmyN">AES加密算法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从工程中删除Cocoapods]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/05/delcocopods/"/>
    <updated>2016-01-05T17:16:42+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/05/delcocopods</id>
    <content type="html"><![CDATA[<p>&emsp;会有这么一种情况，因为需要改动的第三方比较多，不想使用cocoapods管理第三方，这时候，对于已经使用cocoapods的情况，需要进行删除处理，就可以按照以下步骤进行：</p>

<ol>
<li><p>删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹</p></li>
<li><p>删除xcworkspace文件</p></li>
<li><p>使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用</p></li>
<li><p>在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources, 可能还会有Embed Pods Frameworks也删了，总之带有Pods全删了</p></li>
</ol>


<!--more-->


<p><img src="/images/delcocopods.png" alt="删除图" /></p>

<p><strong>注意</strong>:如果将cocoapods集成到工程中后不小心修改或删除了其相关文件导致无法便以通过例如：不小心把</p>

<p>Pods.xcconfig给删除了然后出现diff: /../Podfile.lock: No such file or directory，用上面的方法删除cocoapods后，</p>

<p>再重新$sudo pod install一下就好了。</p>

<p>如果编译的时候出现权限问题，对工程文件夹$sudo chmod 777 path-to-project-folder/*</p>

<p>$sudo chown 777 path-to-project-folder/*</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多样式UILabel]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/04/colorfullabel/"/>
    <updated>2016-01-04T16:22:19+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/04/colorfullabel</id>
    <content type="html"><![CDATA[<p> 有时候产品经理说，能把一句话显示多种颜色、多种字体吗？ 灵光一闪，弄多个UILabel来显示不就行了，我只能说可以，也只能说这法有点笨。于是我坚决不用这种方法，苦思冥想，终于有了眉目。先配张图来显摆显摆，其实很容易实现，我也就不啰嗦了，看招：
 <!--more-->
<img src="http://upload-images.jianshu.io/upload_images/1168293-0ce90e359fcc8c76.png" alt="多样式UILabel" /></p>

<h5>由于很简单，不喜请喷我。</h5>

<p>ok, 上代码，一看也就是一个方法：</p>

<pre><code>
-(void)txtArr:(NSArray *)txtArr colorArr:(NSArray *)colorArr fontArr:(NSArray *)fontArr {

    NSInteger okCount = 0;
    okCount = txtArr.count < colorArr.count ? txtArr.count : colorArr.count;
    okCount = okCount < fontArr.count ? okCount : fontArr.count;

    NSMutableString *txt = [NSMutableString string];
    for (NSString *str in txtArr) {
        [txt appendString:str];
    }
    NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:txt];
    NSInteger startLoc = 0;
    for (int i = 0; i < okCount; i++) {
        [str addAttributes:@{NSForegroundColorAttributeName:colorArr[i], NSFontAttributeName:[UIFont systemFontOfSize:[fontArr[i] integerValue]]} range:NSMakeRange(startLoc, [txtArr[i] length])];
        startLoc += [txtArr[i] length];
    }
    self.attributedText = str;
}
</code></pre>


<h5>参数说明基本都是见明知意（大人，请允许我自恋吧）</h5>

<ol>
<li>txtArr: 传入的文本数组（对象是字符串）</li>
<li>colorArr: 颜色数组  （对象是UIColor）</li>
<li>fontArr: 字体数组  (对象是字符串如：@&ldquo;18&rdquo; 号字体)</li>
</ol>


<h5>使用方法，写给新手哦，老手请过滤吧，不然你又该喷我了</h5>

<p>我还是以代码使用为主</p>

<pre><code>
NSArray *a = [NSArray arrayWithObjects:@"瞅啥瞅", @"我不就是", @"多样式label么，哈哈", nil];

    NSArray *b = [NSArray arrayWithObjects:[UIColor redColor], [UIColor blackColor], [UIColor blueColor], nil];
    NSArray *c = [NSArray arrayWithObjects:@"19", @"13", @"17", nil];
    [self.multiLabel txtArr:a colorArr:b fontArr:c];
</code></pre>


<p>哎，对了，我将此方法写成了UILabel的分类了，所以这么使用没什么不妥；至于分类，不懂得，去google吧，没翻墙的还是百度吧；</p>

<p><a href="https://github.com/Ashen-Zhao/multiLabel">Demo下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 如何随意的push来pop去]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/04/any-push-pop/"/>
    <updated>2016-01-04T11:08:00+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/04/any-push-pop</id>
    <content type="html"><![CDATA[<h2>iOS 导航控制器如何随意push和pop</h2>

<hr />

<p>第一次开始写技术文章，请同学们多多关照，有错的地方请给我指出，大家学习一起成长，好了，我就废话不多少了；</p>

<hr />

<h4>主题思想：如A、B、C、D 四个视图控制器</h4>

<p>想要在 A push B 后， B 在push 到 D ，然后从 D pop 到 C ,在从 C pop 的A</p>

<hr />

<h4>解决方法如下：</h4>

<p>1.假如此时在 A 控制器下，想要到 push 到 B， 可以这样写</p>

<pre><code> [self.navigationController pushViewController: B :YES];
</code></pre>

<p> <!--more-->
这时 <code>self.navigationController.viewControllers</code> 中按顺序含有 [A，B]</p>

<p>2.此时已经到 B 控制器下了， 接下来是 push 到 D, 可以这样写</p>

<pre><code> [self.navigationController pushViewController: D :YES];
</code></pre>

<p>这时 <code>self.navigationController.viewControllers</code> 中按顺序含有 [A，B，D]</p>

<p>接下来<strong>很重要，很重要，很重要</strong>：</p>

<p>如何想从 D pop 到 C, 看数组[A，B，D] 中压根就没有C 该如何pop 到C呢？</p>

<p>这时就需要对这个数组进行修改，将C 加入进去</p>

<p><strong>于是 你会如下写：</strong></p>

<pre><code>[self.navigationController.viewControllers addObject:C]; 
</code></pre>

<p>发现报错，这是因为<code>self.navigationController.viewControllers</code> 是不可变数组，没办法了，我们只好转换一下了：</p>

<pre><code>NSMutableArray*tempMarr =[NSMutableArrayarrayWithArray:self.navigationController.viewControllers];
</code></pre>

<p>此时再加入C 就容易多了，咦，聪明的你会发现从 D pop C 不能直接将 C直接 addObject;</p>

<p><strong>当然，我会这样做：</strong></p>

<pre><code>[tempMarr insertObject:C atIndex:tempMarr.count- 2];
</code></pre>

<p>这时候 <code>tempMarr</code> 是这样的 [A，B，C，D],  可是 要想 从 C pop 到 A ,数组中就不能有 B</p>

<p>就需要 将<code>tempMarr</code> 变成 [A，C，D] ，至于怎么变，你比我懂得多，</p>

<p>懂得思考的同学会发现 这时的<code>self.navigationController.viewControllers</code> 依然是 [A，B，D]， 不用急，不用怕<code>navigationController</code> 有这样一个方法, 可以搞定，如下：</p>

<pre><code>[self.navigationController setViewControllers:tempMarr animated:YES];
</code></pre>

<p>有的同学会说，这不是直接把 B 替换 成 C 吗</p>

<p>看上去是这样，可是跳转的时机，时机，时机重要的事情说三遍，还有视图的切换，切换，切换</p>

<p>此时还在 B 控制器中，这些处理过程都是在 B 中处理的 ， 也必须是 B 执行了 push 到 D 方法后，也就是说</p>

<pre><code>[self.navigationController pushViewController:D animated:YES];
</code></pre>

<p> 之后 进行的 数组处理；</p>

<h4>附加代码：</h4>

<p>在B 控制器中处理：</p>

<pre><code>-(void)pushTest {

    [self.navigationController pushViewController:D animated:YES];

NSMutableArray*tempMarr =[NSMutableArrayarrayWithArray:self.navigationController.viewControllers];

[tempMarr insertObject:C atIndex:tempMarr.count- 2];

[tempMarr removeObject:self]; //此时 的self 就是指 B ,因为在 B 中呢

[self.navigationController setViewControllers:tempMarr animated:YES];

}
</code></pre>

<p><a href="https://github.com/Ashen-Zhao/anypushpop">Demo下载地址</a></p>
]]></content>
  </entry>
  
</feed>
