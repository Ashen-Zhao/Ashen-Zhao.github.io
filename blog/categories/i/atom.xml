<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 啊神的技术博客]]></title>
  <link href="http://ashen-zhao.github.io/blog/categories/i/atom.xml" rel="self"/>
  <link href="http://ashen-zhao.github.io/"/>
  <updated>2017-03-22T17:34:48+08:00</updated>
  <id>http://ashen-zhao.github.io/</id>
  <author>
    <name><![CDATA[Ashen]]></name>
    <email><![CDATA[zhaoashen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UITableView重用机制导致CABasicAnimation动画失效]]></title>
    <link href="http://ashen-zhao.github.io/blog/2017/03/02/dong-hua-shi-xiao/"/>
    <updated>2017-03-02T18:24:49+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2017/03/02/dong-hua-shi-xiao</id>
    <content type="html"><![CDATA[<p>开发随记，再给cell上添加一个小动画图片时，遇到一个很蛋疼的问题，动画明明会动，而且退出后台在回来也会动，可就是拉出屏幕外，在回来时，动画失效了，不会动了。以下是动画代码，就是一个简单的摇摆动画</p>

<pre><code>let rotationAnim = CABasicAnimation(keyPath: "transform.rotation.z")
            rotationAnim.toValue = M_PI/5
            rotationAnim.autoreverses = true
            rotationAnim.repeatCount = MAXFLOAT
            rotationAnim.duration = 0.2
            rotationAnim.isRemovedOnCompletion = false
            moveImgv.layer.add(rotationAnim, forKey: nil)
</code></pre>

<!--more-->


<p>于是就开始看CABasicAnimation的类的属性说明，该设置的都设置了，可还是不行，百度，谷歌，搜狗统统找不到原因，全是CABasicAnimation的简单教程。</p>

<p>无奈至极呀，就开始检查代码，看有没有可以修改的地方，一通乱世只会，在上面代码中的最后一行<br/>
<code>moveImgv.layer.add(rotationAnim, forKey: nil)</code></p>

<p>我发现forkey是nil，可当我给它一个值的时候，</p>

<p><code>moveImgv.layer.add(rotationAnim, forKey: "moveanimation")</code><br/>
再次调试，却发现重用后，动画终于可以动了，原来我废了那么久的时间，却是这样的问题，真是想哭，又想笑😁。</p>

<p>就是这样的问题，在网上找了好久，却找不到结果，可能是大家都写了key了吧，在此写下这边文章，希望有遇到像我一样的问题的同学可以找到解决办法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS自动打包上传脚本]]></title>
    <link href="http://ashen-zhao.github.io/blog/2017/02/22/autobuild/"/>
    <updated>2017-02-22T16:46:25+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2017/02/22/autobuild</id>
    <content type="html"><![CDATA[<p>自从将swift2.2升级到swift3.0, 每次使用Xcode8编译都很慢，很是不爽，于是有了研究下xcodebuild命令行打包的想法，起初不知道用shell，还是用python, 在网上大概搜了一下，关于python的比较多点，于是就先学习python的基础语法，然后再去看看大神的一些脚本，就开始专研命令行打包了。总之，过程很艰辛，结果很满意，以下便是我修改后的<a href="https://github.com/ashen-zhao/autobuild">python自动打包脚本</a>，命令行使用，打包完成会询问是否上传蒲公英平台，以及询问是否上传appstore，还有是否保留archive文件。<br/>
<a href="https://github.com/ashen-zhao/autobuild">自动打包脚本下载地址</a></p>

<!--more-->


<h3>使用方法</h3>

<p>1、下载完成后，将autobuild.py以及exportOptions.plist文件放到你的项目跟目录下（即与xx.xcworkspace或者xx.xcworkspace在同一个目录下）<br/>
2、打开autobuild.py，修改配置信息<br/>
3、打开命令终端，进入项目根目录<br/>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;a.如果你是xx.xcworkspace<br/>
&emsp;&emsp;    <code>./autobuild.py -p youproject.xcodeproj</code><br/>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.如果你是xx.xcworkspace<br/>
&emsp;&emsp; <code>./autobuild.py -w youproject.xcworkspace</code></p>

<p>4、等待终端回应，依据终端提示进行相关操作<br/>
5、最终会在桌面生成带有时间戳的文件夹，含义ipa以及xcarchive文件</p>

<pre>
#!/usr/bin/env python
# -*- coding:utf-8 -*-

#./autobuild.py -p youproject.xcodeproj
#./autobuild.py -w youproject.xcworkspace

import argparse
import subprocess
import requests
import os
import datetime

#configuration for iOS build setting
CONFIGURATION = "Release"
EXPORT_OPTIONS_PLIST = "exportOptions.plist"

#发布版本号
VERSION = '1.0.0'
BUILD = '17021803'

#要打包的TARGET名字
TARGET = 'ULife'

#Info.plist路径
PLIST_PATH = "xxxxxx/Info.plist"

#存放路径以时间命令
DATE = datetime.datetime.now().strftime('%Y-%m-%d_%H.%M.%S')

#会在桌面创建输出ipa文件的目录
EXPORT_MAIN_DIRECTORY = "~/Desktop/" + TARGET + DATE

#xcarchive文件路径（含有dsym），后续查找BUG用途
ARCHIVEPATH = EXPORT_MAIN_DIRECTORY + "/%s%s.xcarchive" %(TARGET,VERSION)

#ipa路径
IPAPATH = EXPORT_MAIN_DIRECTORY + "/%s.ipa" %(TARGET)

#苹果开发者账号
APPLEID = 'xxxxxx'
APPLEPWD = 'xxxxx'

# configuration for pgyer
PGYER_UPLOAD_URL = "http://www.pgyer.com/apiv1/app/upload"
DOWNLOAD_BASE_URL = "http://www.pgyer.com"
USER_KEY = "xxxxxx"
API_KEY = "xxxxx"
#设置从蒲公英下载应用时的密码
PYGER_PASSWORD = "xxxxx"

def cleanArchiveFile():
    cleanCmd = "rm -r %s" %(ARCHIVEPATH)
    process = subprocess.Popen(cleanCmd, shell = True)
    process.wait()
    print "cleaned archiveFile: %s" %(ARCHIVEPATH)

def uploadIpaToAppStore():
    print "iPA上传中...."
    altoolPath = "/Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool"

    exportCmd = "%s --validate-app -f %s -u %s -p %s -t ios --output-format xml" % (altoolPath, IPAPATH, APPLEID,APPLEPWD)
    process = subprocess.Popen(exportCmd, shell=True)
    (stdoutdata, stderrdata) = process.communicate()

    validateResult = process.returncode
    if validateResult == 0:
        print '~~~~~~~~~~~~~~~~iPA验证通过~~~~~~~~~~~~~~~~'
        exportCmd = "%s --upload-app -f %s -u %s -p %s -t ios --output-format normal" % (
        altoolPath, IPAPATH, APPLEID, APPLEPWD)
        process = subprocess.Popen(exportCmd, shell=True)
        (stdoutdata, stderrdata) = process.communicate()

        uploadresult = process.returncode
        if uploadresult == 0:
            print '~~~~~~~~~~~~~~~~iPA上传成功'
        else:
            print '~~~~~~~~~~~~~~~~iPA上传失败'
    else:
        print "~~~~~~~~~~~~~~~~iPA验证失败~~~~~~~~~~~~~~~~"

def parserUploadResult(jsonResult):
    resultCode = jsonResult['code']
    if resultCode == 0:
        downUrl = DOWNLOAD_BASE_URL +"/"+jsonResult['data']['appShortcutUrl']
        print "Upload Success"
        print "DownUrl is:" + downUrl
    else:
        print "Upload Fail!"
        print "Reason:"+jsonResult['message']

def uploadIpaToPgyer(ipaPath):
    print "ipaPath:"+ipaPath
    ipaPath = os.path.expanduser(ipaPath)
    ipaPath = unicode(ipaPath, "utf-8")
    files = {'file': open(ipaPath, 'rb')}
    headers = {'enctype':'multipart/form-data'}
    payload = {'uKey':USER_KEY,'_api_key':API_KEY,'publishRange':'2','isPublishToPublic':'2', 'password':PYGER_PASSWORD}
    print "uploading...."
    r = requests.post(PGYER_UPLOAD_URL, data = payload ,files=files,headers=headers)
    if r.status_code == requests.codes.ok:
        result = r.json()
        parserUploadResult(result)
    else:
        print 'HTTPError,Code:'+r.status_code

def exportArchive():
    exportCmd = "xcodebuild -exportArchive -archivePath %s -exportPath %s -exportOptionsPlist %s" %(ARCHIVEPATH, EXPORT_MAIN_DIRECTORY, EXPORT_OPTIONS_PLIST)
    process = subprocess.Popen(exportCmd, shell=True)
    (stdoutdata, stderrdata) = process.communicate()

    signReturnCode = process.returncode
    if signReturnCode != 0:
        print "export %s failed" %(TARGET)
        return ""
    else:
        return EXPORT_MAIN_DIRECTORY

def buildProject(project):
    archiveCmd = 'xcodebuild -project %s -scheme %s -configuration %s archive -archivePath %s -destination generic/platform=iOS' %(project, TARGET, CONFIGURATION, ARCHIVEPATH)
    process = subprocess.Popen(archiveCmd, shell=True)
    process.wait()

    archiveReturnCode = process.returncode
    if archiveReturnCode != 0:
        print "archive project %s failed" %(project)
        cleanArchiveFile()

def buildWorkspace(workspace):
    archiveCmd = 'xcodebuild -workspace %s -scheme %s -configuration %s archive -archivePath %s -destination generic/platform=iOS' %(workspace, TARGET, CONFIGURATION, ARCHIVEPATH)
    process = subprocess.Popen(archiveCmd, shell=True)
    process.wait()

    archiveReturnCode = process.returncode
    if archiveReturnCode != 0:
        print "archive workspace %s failed" %(workspace)
        cleanArchiveFile()

def xcbuild(options):
    project = options.project
    workspace = options.workspace

    if project is None and workspace is None:
        pass
    elif project is not None:
        buildProject(project)
    elif workspace is not None:
        buildWorkspace(workspace)

    #导出ipa文件
    exportarchive = exportArchive()
    print "~~~~~~~~~~~~~~~~是否上传到蒲公英~~~~~~~~~~~~~~~~"
    print "        1 不上传 (默认)"
    print "        2 上传 "
    isuploadpgyer = raw_input("您的决定：")
    if isuploadpgyer == "2" and exportarchive != "":
        uploadIpaToPgyer(IPAPATH)

    print "~~~~~~~~~~~~~~~~是否上传到AppStore~~~~~~~~~~~~~~~~"
    print "        1 不上传 (默认)"
    print "        2 上传 "
    isuploadappstore = raw_input("您的决定：")
    if isuploadappstore == '2':
        uploadIpaToAppStore()
    else:
        print "~~~~~~~~~~~~~~~~是否删除archive文件~~~~~~~~~~~~~~~~"
        print "        1 保留 (默认)"
        print "        2 删除 "
        iscleararchive = raw_input("您的决定：")
        if iscleararchive == "2":
            cleanArchiveFile()


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument("-w", "--workspace", help="Build the workspace name.xcworkspace.", metavar="name.xcworkspace")
    parser.add_argument("-p", "--project", help="Build the project name.xcodeproj.", metavar="name.xcodeproj")

    options = parser.parse_args()

    print "options: %s" % (options)

    os.system('/usr/libexec/PlistBuddy -c "Set:CFBundleShortVersionString %s" %s' % (VERSION,PLIST_PATH))
    os.system('/usr/libexec/PlistBuddy -c "Set:CFBundleVersion %s" %s' % (BUILD, PLIST_PATH))

    xcbuild(options)

if __name__ == '__main__':
    main()

</pre>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[集成友盟分享中遇到的奇怪的错误]]></title>
    <link href="http://ashen-zhao.github.io/blog/2017/02/14/qi-guai-de-cuo-wu/"/>
    <updated>2017-02-14T13:35:47+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2017/02/14/qi-guai-de-cuo-wu</id>
    <content type="html"><![CDATA[<h3>开发中遇到的一些看似不起眼的警告，往往却是问题的所在！</h3>

<hr />

<p>这不，这次我就遇到了这个坑，为了提醒自己不要轻易忽略警告，以此文章记录一下，埋坑的艰辛。</p>

<p>我是在集成友盟分享SDK的时候，使用<code>cocoapods</code>导入的友盟分享组件，在命令行敲下pod install只会，安装也完成了，就是出现以下一些警告，我大概浏览了一下，看不出所以然，就没管, 继续在集成。</p>

<!--more-->


<p><i>[!] The <code>ULife [Debug]</code> target overrides the <code>OTHER_LDFLAGS</code> build setting defined in <code>Pods/Target Support Files/Pods-ULife/Pods-ULife.debug.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the</code>$(inherited)` flag, or
    - Remove the build settings from the target.</p>

<p>[!] The <code>ULife [Release]</code> target overrides the <code>OTHER_LDFLAGS</code> build setting defined in <code>Pods/Target Support Files/Pods-ULife/Pods-ULife.release.xcconfig'. This can lead to problems with the CocoaPods installation
    - Use the</code>$(inherited)` flag, or
    - Remove the build settings from the target.<br/>
</i></p>

<p>直到我开始使用友盟的一些类库时，使用也是没有问题的，可当我编译时，却出现了以下错误信息：</p>

<p><i>Undefined symbols for architecture arm64:
  &ldquo;<em>OBJC_CLASS</em>$_UMSocialManager&rdquo;, referenced from:
      objc-class-ref in AppDelegate.o
ld: symbol(s) not found for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation) </i></p>

<p>咋一看，还以为是不支持64位呢，可是官方明明写着支持64位的，也就没有去怀疑官方，就开始各种清理缓存，重复编译，各种谷歌，百度，可终究没有可行的办法。去友盟问客服，沟通成本太高，每次掉线，重新连接又是一个新人，也未能解决。</p>

<p>实在没有办法了，我又重新pod update一下，这次发现依然是上面提到的警告信息，这次我没有忽略，而是仔细的看了下，大概知道了，产生此警告的原因是项目 Target 中的一些设置，CocoaPods 也做了默认的设置，如果两个设置结果不一致，就会造成问题。</p>

<p>警告中，提示要想使用cocoapods中的设置，需要在项目中定义<code>PODS_ROOT</code> 和 <code>Other Linker Flags</code>的地方，把他们的值用<code>$(inherited)</code>替换掉。</p>

<p>大致解决办法知道了， 开始在<code>Build Settings</code>中的PODS_ROOT<code>和</code>Other Linker Flags<code>处进行修改，添加一项</code>$(inherited)<code>，Other Linker Flags</code>我这里没有替换掉，而是添加一项，怕我本来的项也是有用的，就没有替换。</p>

<p>最后修改后，我再次编译，竟然通过了，我喜极而泣的写下了这篇文章来记录下这次忽略警告的教训经历。</p>

<hr />

<p>注：在我在网上搜索时，有说，点击项目文件 project.xcodeproj，右键<code>显示包内容</code>，用文本编辑器打开<code>project.pbxproj</code>，删除<code>OTHER_LDFLAGS</code>的地方，保存，回到 Xcode，编译也能通过。这种删除内容的解决办法，我一般不轻易使用的，所以我没有去证实这种做法，若有兴趣，你可以尝试下，不过做好备份哦~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探索Xcode8编译为什么那么慢？]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/12/21/xcode8build/"/>
    <updated>2016-12-21T10:12:58+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/12/21/xcode8build</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>随着<code>Xcode8</code>和<code>swift3.0</code>的正式到来，我开始着手将<code>swift2.3</code>的项目转到<code>swift3</code>（至于转换过程，这里不多做介绍，Xcode自带的转换工具，基本可以转换80%左右，剩下的自己慢慢调试即可。）但是，转到swift3只会，在用Xcode8编译，发现编译过程变得非常慢，哪怕打一个空格，都要重新编译很久。于是在网上查找解决办法，查找了半天各种方法全用，发现于事无补。<br/>
&emsp;&emsp;有什么加一个<code>HEADERMAP_USES_VFS = YES</code>（）<a href="http://www.cnblogs.com/qqsscc/p/6044234.html">这是地址，反正这个对我没用，感兴趣的话自己试试</a></p>

<h5>针对这种情况，我就自己探索，出发点是排查哪些文件，哪些方法导致编译变慢？</h5>

<h3>探索Xcode编译，在哪些地方可以看到编译文件过程</h3>

<hr />

<p>通过多次编译查看，发现在Xcode左边栏，最后一个选项，是每次的编译运行等记录， 每行记录中都会有每次编译的文件编译记录。如下图</p>

<!--more-->


<p>
<img src="/images/build1.png" alt="图1" /></p>

<p>再次查看正在编译的一条记录(正在编译的记录后面有一个转圈圈的”菊花“)，发现有图中1、2两种标识， 一个绿色✅说明，这是编译完成了，另一个是灰色→箭头，说明是正在编译；此时发现灰色一直停留在这里，指向图中的文件，左边的菊花一直转个不停， 编译卡住了。这样一来就找到编译是什么文件导致的那么慢。</p>

<p><img src="/images/build2.png" alt="图2" /></p>

<h3>排查文件中哪些代码导致的编译卡住？</h3>

<hr />

<p>排查的方法，采用比较笨的方法，暴力注释方法：<strong><em>就是注释找到卡住的文件中的所有方法里的代码，不要注释方法，再次编译，此时发现该文件很快通过编译，然后在依次解开部分方法注释，再次编译，直到发现解开某个方法的注释后，编译再次卡住，那就说明那个方法中的代码写的有问题，然后在依次注释，解开注释，排查方法中的某一行代码的问题。</em></strong>经过一番排查，我找到了我代码中卡住的部分代码，如下图红色圈中的代码</p>

<p><img src="/images/build3.png" alt="图3" /></p>

<p><font color=red>在字典中的key对应的value，没有给直接的值，而是给出一个表达式，这样会导致Xcode8的编译速度极其慢，不知道为什么会出现这样的问题，之前的Xcode版本是没有的。</font></p>

<p>找到问题所在，解决问题就简单了，于是修改代码如下图：</p>

<p><img src="/images/build4.png" alt="图4" /></p>

<p>修改之后，再次编译，重新回到了快速编译的时代了，再也不用等上5-10分钟不等了。</p>

<p>  以上过程，是针对我遇到的问题而言的，不知道是否存在普遍性，如若你也遇到，刚好看了我的文章，也解决了问题，那就会心一笑吧，如若你也遇到了，但是没有解决问题，也请你会心一笑吧。<br/>
     <a href="https://forums.developer.apple.com/thread/62737">这是苹果开发者提到的Xcode8编译超慢的问题，我看了下，也做了对应修改，发现对我并没有什么用， 感兴趣的话进去看看吧</a></p>

<p>有时候自己慢慢去探索出问题的所在，也是很不错的体验。</p>

<hr />

<h3>后知后觉</h3>

<hr />

<p>后来我知道了，也可以通过，查看具体的swift函数编译时间来定位哪个函数卡住了，而不用<code>暴力注释法</code>.<br/>
首先要到Build Settings 给 Other Swift Flags  添加一项<code>
-Xfrontend -debug-time-function-bodies</code> <br/>
就可以查看编译通过的文件中的函数编译时间，找到绿色✅的文件的那一行，在最后面有一个图标，点击展开具体内容，向下移动就会看到每个函数执行的具体时间。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中的网络加密]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/08/05/https/"/>
    <updated>2016-08-05T17:28:40+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/08/05/https</id>
    <content type="html"><![CDATA[<h2>iOS 中的网络加密</h2>

<hr />

<h5>引言：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。</h5>

<h3>HTTPS交互原理</h3>

<p>简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。</p>

<h4>HTTPS 客户端与服务器交互过程：</h4>

<p>1）客户端发送请求，服务器返回公钥给客户端；</p>

<p>2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；</p>

<p>3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；</p>

<p>4）之后的交互都使用对称加密后的数据进行交互。</p>

<!--more-->


<h3>证书</h3>

<p>简单说，证书有两种，一种是正经的：</p>

<p>CA颁发的证书</p>

<p>一种是不正经的：</p>

<p>自己生成签发的证书</p>

<h3>我们需要做什么</h3>

<p>如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：</p>

<p>1）将服务器的公钥证书拖到Xcode中</p>

<p>2）修改验证模式</p>

<pre><code>manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];
</code></pre>

<h3>原理</h3>

<p>简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];
securityPolicy.allowInvalidCertificates = YES;
</code></pre>

<h3>解决方法</h3>

<p>AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式</p>

<pre><code>openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer
</code></pre>

<p>然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];
</code></pre>

<p>或者</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];
</code></pre>

<p>情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。</p>

<h3>AFSecurityPolicy三种验证模式</h3>

<p>1）AFSSLPinningModeNone
这个模式表示不做SSL pinning，
只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。</p>

<p>2）AFSSLPinningModeCertificate
这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</p>

<p>3）AFSSLPinningModePublicKey
这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，
只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</p>

<hr />

<p>此文章转载自：<a href="http://charsdavy.github.io/2016/06/15/ios-network-encrypt">http://charsdavy.github.io/2016/06/15/ios-network-encrypt</a> <br/>
感谢原作者让我们又学到了知识。</p>
]]></content>
  </entry>
  
</feed>
