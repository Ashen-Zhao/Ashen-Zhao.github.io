<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 啊神的技术博客]]></title>
  <link href="http://ashen-zhao.github.io/blog/categories/i/atom.xml" rel="self"/>
  <link href="http://ashen-zhao.github.io/"/>
  <updated>2016-10-20T16:48:52+08:00</updated>
  <id>http://ashen-zhao.github.io/</id>
  <author>
    <name><![CDATA[Ashen]]></name>
    <email><![CDATA[zhaoashen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 中的网络加密]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/08/05/https/"/>
    <updated>2016-08-05T17:28:40+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/08/05/https</id>
    <content type="html"><![CDATA[<h2>iOS 中的网络加密</h2>

<hr />

<h5>引言：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。</h5>

<h3>HTTPS交互原理</h3>

<p>简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。</p>

<h4>HTTPS 客户端与服务器交互过程：</h4>

<p>1）客户端发送请求，服务器返回公钥给客户端；</p>

<p>2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；</p>

<p>3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；</p>

<p>4）之后的交互都使用对称加密后的数据进行交互。</p>

<!--more-->


<h3>证书</h3>

<p>简单说，证书有两种，一种是正经的：</p>

<p>CA颁发的证书</p>

<p>一种是不正经的：</p>

<p>自己生成签发的证书</p>

<h3>我们需要做什么</h3>

<p>如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：</p>

<p>1）将服务器的公钥证书拖到Xcode中</p>

<p>2）修改验证模式</p>

<pre><code>manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];
</code></pre>

<h3>原理</h3>

<p>简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];
securityPolicy.allowInvalidCertificates = YES;
</code></pre>

<h3>解决方法</h3>

<p>AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式</p>

<pre><code>openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer
</code></pre>

<p>然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];
</code></pre>

<p>或者</p>

<pre><code>AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];
</code></pre>

<p>情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。</p>

<h3>AFSecurityPolicy三种验证模式</h3>

<p>1）AFSSLPinningModeNone
这个模式表示不做SSL pinning，
只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。</p>

<p>2）AFSSLPinningModeCertificate
这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</p>

<p>3）AFSSLPinningModePublicKey
这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，
只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</p>

<hr />

<p>此文章转载自：<a href="http://charsdavy.github.io/2016/06/15/ios-network-encrypt">http://charsdavy.github.io/2016/06/15/ios-network-encrypt</a> <br/>
感谢原作者让我们又学到了知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二维码扫描识别]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/07/20/qrcode/"/>
    <updated>2016-07-20T14:31:51+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/07/20/qrcode</id>
    <content type="html"><![CDATA[<p>&emsp;最近忙于工作，工作之余也在学习swift，在github上开源了正在开发维护的swift项目<a href="https://github.com/ashen-zhao/baisiapp">模仿的百思不得姐</a>；不过今天不是来介绍这个开源项目的，而是来给大家介绍一个很简单的功能之 iOS 二维码扫描识别；</p>

<h5>我将该功能进行了简单的封装，只需要简单调用就可以实现；</h5>

<h5>封装文件：</h5>

<p><code>QRCodeManager.h</code>该文件是封装的二维码识别功能</p>

<h5>调用方法：</h5>

<pre><code>    _qr = [[QRCodeManager alloc] init];
     _qr.delegate = self;
    [_qr configureManager:self.view];
</code></pre>


<p></p>

<h5>服从协议<code>QRCodeManagerDelegate</code>实现代理方法：</h5>

<p><code>- (void)qrCodeResult:(NSString *)result</code> ，result即为扫描识别到的二维码信息了，就是这么简单。</p>

<h4>Demo示例图</h4>

<p><img src="/images/qrcode.gif" alt="二维码扫描识别" /></p>

<h4>Demo源码地址：</h4>

<p><a href="https://github.com/ashen-zhao/asqrcode">二维码扫描识别Demo下载地址</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让UIImageView显示Gif图]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/04/14/gifimageview/"/>
    <updated>2016-04-14T13:57:05+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/04/14/gifimageview</id>
    <content type="html"><![CDATA[<p>&emsp;各位同学们，这次给大家分享一个小工具，可以解决你在开发过程中，需要显示Gif图片的需求；由于太过于简单，我这里就不多说了；有需要的同学，请前往<a href="https://github.com/ashen-zhao/asGifImageView">https://github.com/ashen-zhao/asGifImageView</a>进行下载，不需要的同学也可以去Star，留着以后使用，最后，记得关注我哦，哈哈😄；</p>

<h2>接下来，简单写一下如何使用该工具</h2>

<h4>示例图</h4>

<p><img src="/images/gifView.gif" alt="啊神gifUIImageView" /></p>

<h4>功能说明：</h4>

<p>这是一个UIImageView的分类，可以让UIImageView支持显示本地Gif以及网络Gif图片。</p>

<h4>使用说明</h4>

<p>1.导入分类头文件 <code>#import "UIImageView+ASGif.h"</code><br/>
2.调用<br/>
&emsp;a.显示本地gif图片 <br/>
    <code>[self.gifImgV showGifImageWithData:[NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"abc" ofType:@"gif"]]];</code><br/>
&emsp;b.显示网络gif图片<br/>
       <code>[self.gifImgV showGifImageWithURL:[NSURL URLWithString:@"http://ww1.sinaimg.cn/large/85cccab3gw1etdi67ue4eg208q064n50.gif"]];</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS之接地气的移动支付]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/26/pay/"/>
    <updated>2016-01-26T11:15:35+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/26/pay</id>
    <content type="html"><![CDATA[<h3>iOS 移动支付之种类</h3>

<p>iOS 端的移动支付，大概包括：支付宝支付、微信支付、银联卡支付、paypal支付，现在又多出一个Apple pay支付；</p>

<h3>如何集成这些种类的支付方式</h3>

<p>谈及如何集成这些支付方式，面对各种支付方式的SDK以及Demo写的详细的完美无缺，我还真不如还如何去写，这里我就接地气的写写，写的不好请勿喷哦☺！</p>

<h3>支付宝支付</h3>

<h3>大致有以下步骤：</h3>

<h4>1.向支付宝申请, 与支付宝签约，获得商户PID（partner）和账号ID（seller）和私钥(privateKey)</h4>

<p>注：*这一步，一般公司会搞定的，这里只是让你知道来龙去脉☺<br/>
&emsp; 没有支付宝账号的同学，可以<a href="https://memberprod.alipay.com/account/reg/index.htm">点击这里注册账号</a>; <br/>
&emsp; 已经有支付宝账号的同学<a href="https://b.alipay.com/order/productDetail.htm?productId=2015110218010538">点击这里申请移动支付</a><br/>
申请签约有个门槛比较难，就是不管你是个人还是企业，都需要营业执照，这点有点蛋疼，不过人家也是为了有质量的管理申请者嘛，可以理解，我这里没有营业执照，申请工作就死在了摇篮里，不过大致流程，我基本弄清楚了，<strong>不过作为开发者，这申请工作就不用多关心了，一般公司都会有申请过的</strong>，我这里写出来也就是让我们开发者也大概知道流程，而不是直接就是用，只知去向，不知来龙。  <br/>
申请签约成功后，就可以查看 PID（partner）和账号ID（seller）和私钥(privateKey) ，<a href="https://b.alipay.com/order/serviceIndex.htm">查看地址点击这里</a> 进行登录，点击下图中的查询PID和Key;<br/>
<img src="/images/pay01.png" alt="Pay" /></p>

<!--more-->


<p>但是这里查询到的Key 是公钥，不是私钥，你到底该怎么弄私钥呢？同学们，不用急，支付宝文档写的还是比较清楚的，<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.cxzipP&amp;treeId=58&amp;articleId=103242&amp;docType=1">点击这里可以查看RSA私钥及公钥生成</a></p>

<p>这里文档给出了两种平台下的生产方式，我们既然是iOS 开发者，那就选择Linux用户生产的方式吧，可以直接在Mac的终端敲这些命令；
<img src="/images/pay02.png" alt="啊神支付" /><br/>
敲过这些命令后，会在本地生产两个文件，分别是私钥和公钥文件<br/>
在命令行敲入（以行为单位）<br/>
$cd ~/<br/>
$open .  //打开文件的存放位置<br/>
想要查看文件内容，还需要使用命令<br/>
$cat rsa_private_key.pem  //会在终端显示文件中的内容，这就是私钥<br/>
到这里，第一步基本上就可以了，具体还需要自己动手试试，不然还是会一头雾水。</p>

<h4>2.下载支付宝SDK以及Demo</h4>

<p>这一步，没啥好说的，给个地址就行<a href="https://doc.open.alipay.com/doc2/detail.htm?treeId=54&amp;articleId=104509&amp;docType=1">SDK以及Demo下载地址</a></p>

<h4>3.集成SDK到工程中（生成订单信息,签名加密）</h4>

<h5>支付宝官方集成文档</h5>

<p>集成支付宝SDK的步骤，这里是官方给出的<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.SiPSmP&amp;treeId=59&amp;articleId=103676&amp;docType=1">集成文档</a>, 按照步骤集成总是会出错，这不是我们脑子不行，而是官方毕竟是官方。<br/>
查看支付宝给出的Demo，会发现这些文件必须要加到项目中：
<img src="/images/pay05.png" alt="啊神" /><br/>
其中小方框中的为必须加入，而除了小方框以外的，那就要看你们后台人员是否将签名成功字符串格式化的订单字符串，给你传到前端来，如果没有，那就必须你自己在前端处理； 按理说，这些应该由后台来处理，为了订单信息的安全，以及前端业务的轻运行，都该有后端来处理（注：这点不懂，不要紧，后面还会根据代码在进行讲解;</p>

<h5>集成中可能遇到的错误</h5>

<p>1）Cannot find interface declaration for &lsquo;NSObject&rsquo;<br/>
<img src="/images/pay03.png" alt="啊神" /><br/>
解决方案：a. 可以在报错的文件中加入<code>#import &lt;Foundation/Foundation.h&gt;</code><br/>
b. 可以建个pch文件加入</p>

<pre>`
#ifdef __OBJC__
#import UIKit/UIKit.h
#import Foundation/Foundation.h
#endif
`</pre>


<p></p>

<p>2)提示找不到 openssl/asn1.h 文件<br/>
<img src="/images/pay06.png" alt="啊神" /><br/>
解决方案：Build Settings &ndash;> Search Paths &ndash;> Header Search paths:$(PROJECT_DIR)/ASPayDemo/Alipay<br/>
<img src="/images/pay07.png" alt="啊神" /></p>

<p>3)_CNCopyCurrentNetworkInfo,referenced from:<br/>
<img src="/images/pay08.png" alt="啊神" /><br/>
解决方案：添加SystemConfiguration.framework</p>

<p><img src="/images/pay09.png" alt="啊神" /></p>

<h4>部署代码</h4>

<pre>
<code>

    NSString *partner = @""; //PID

    NSString *seller = @""; //收款账户，手机号或者邮箱
   
    NSString*privateKey= @"";// 私钥
    
    if ([partner length] == 0 ||
        [seller length] == 0 ||
        [privateKey length] == 0)
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"提示"
                                                        message:@"缺少partner或者seller或者私钥。"
                                                       delegate:self
                                              cancelButtonTitle:@"确定"
                                              otherButtonTitles:nil];
        [alert show];
        return;
    }
    
    Order *order = [[Order alloc] init];
    order.partner = partner;
    order.seller = seller;
    order.tradeNO = @"20160324012412412"; //订单ID（由商家自行制定）
    order.productName = @"iOS 高级教程"; //商品标题
    order.productDescription = @"这是一本关于iOS的一本高级教程书"; //商品描述
    order.amount = @"0.1"; //商品价格
    order.notifyURL = @"http://www.devashen.com/Notify/Alipay/"; //回调URL
    
    order.service = @"mobile.securitypay.pay";
    order.paymentType = @"1";
    order.inputCharset = @"utf-8";
    order.itBPay = @"30m";
    order.showUrl = @"m.alipay.com";
    
    NSString *appScheme = @"alisdkdemo";
    
    //将商品信息拼接成字符串   该方法支付宝已经封好
    NSString *orderSpec = [order description];
    
    
    //获取私钥并将商户信息签名,外部商户可以根据情况存放私钥和签名,只需要遵循RSA签名规范,并将签名字符串base64编码和UrlEncode
    id<DataSigner> signer = CreateRSADataSigner(privateKey);
    //调用签名
    NSString *signedString = [signer signString:orderSpec];
    
    
    
    
    //将签名成功字符串格式化为订单字符串,请严格按照该格式
    NSString *orderString = nil;
    if (signedString != nil) {
        orderString = [NSString stringWithFormat:@"%@&sign=\"%@\"&sign_type=\"%@\"",
                       orderSpec, signedString, @"RSA"];
        
        
        //***************上面提到好的后台，会把订单字符串直接传给我们，而我们要做的其实也就只剩下这一步了********************/
        [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) {
            if ([[resultDic objectForKey:@"resultStatus"] isEqualToString:@"9000"]) {
                //9000为支付成功
                
            }
            
        }];
    }

</code></pre>


<p>
看代码，如果后台将签名成功字符串格式化的订单字符串，给你传到前端来，那我们就只需要做很少的工作就可以了，只需要直接处理订单字符串即可：</p>

<pre><code>
        [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) {
            if ([[resultDic objectForKey:@"resultStatus"] isEqualToString:@"9000"]) {
                //9000为支付成功
                
            }
            
        }];
</code></pre>


<p>
最后，千万别忘了，在Appdelegate中，处理支付宝客户端返回url处理方法, 少了这一步，支付宝SDK的回调方法是不会执行的：</p>

<pre><code>
- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
   //跳转支付宝钱包进行支付，处理支付结果
        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) {
            NSLog(@"result = %@",resultDic);
        }];
    return YES;
}
</code></pre>


<p>
到这里，支付宝支付基本上完成， 迫不及待的你，赶紧去试验试验吧， 别忘了给你们相关负责人要对应的PID、收款账号、以及私钥，当然如果后台直接传给你订单字符串的话，你可以直接给后台要接口了，置于PID什么的你就不用管了。</p>

<h5>相关连接</h5>

<p><a href="https://github.com/ashen-zhao/aspay">本文章对应的Demo, 包含后端是、否给你订单字符串的两种处理</a></p>

<p><a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.AIe1BQ&amp;treeId=59&amp;articleId=103563&amp;docType=1">支付宝移动支付SDK官方文档</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[仿照微博、微信弹出ActionSheet样式]]></title>
    <link href="http://ashen-zhao.github.io/blog/2016/01/22/assheet/"/>
    <updated>2016-01-22T15:08:16+08:00</updated>
    <id>http://ashen-zhao.github.io/blog/2016/01/22/assheet</id>
    <content type="html"><![CDATA[<p>&emsp;iOS 开发中，很多应用都会用到从屏幕底部弹出的UIActionSheet, 但是使用的过程中，总感觉系统的样式怪怪的，或者与自己开发的App的UI不是很协调，总之与自己的App搭配就一个字：丑。 说起ActionSheet样式，应该来看看主流的微博与微信是什么样式的；</p>

<p><img src="http://ashen-zhao.github.io/images/assheet02.PNG" width="200" height="370" alt="微信">
<img src="http://ashen-zhao.github.io/images/assheet01.PNG" width="200" height="370" alt="微博"></p>

<p>看上去的确挺自然，一点也不像系统自带的，给人的感觉就是不协调，不协调的</p>

<!--more-->


<p><img src="http://ashen-zhao.github.io/images/assheet03.png" width="200" height="370" alt="微信"></p>

<p>看吧,系统的与人家设计的，看上去就逊色许多。
出于比较喜欢微博、微信这种设计，就自己动手鼓弄着也写了个<a href="https://github.com/Ashen-Zhao/ASSheet">工具类</a>，为以后使用做准备，使用起来很简单，只需传入titles 数组，以及实现一个Block 点击回调，就可以很快的实现像微博微信那样的样式，先看看效果图吧：</p>

<p><img src="/images/assheet04.gif" alt="啊神ActionSheet" /></p>

<h3>我是如何实现的</h3>

<p>&emsp;写一个继承自UIView的类，用这个view 来做为弹出后的幕布（也就是半透明的背景），然后给这个view 添加一个单击手势，手势方法就是讲该view移除隐藏的方法，然后将次view 背景色设置成半透明, 用 <code>[self setBackgroundColor:[UIColor colorWithWhite:0.5 alpha:0.5]]</code> 来设置半透明背景色。<br/>
&emsp;然后再定义个UIview *titleBgkView属性，该view 用来当titles 的幕布， 随后创建该view， 并且将此view 的frame 根据titles 的多少进行动态调整，我这里重写了大幕布的init 方法<code>- (instancetype)initWithFrame:(CGRect)frame titleArr:(NSArray *)titleArr</code> 传入titles 数组。 <br/>
&emsp;再然后，根据传入的titles 进行创建title按钮，将创建的按钮添加到titleBgkView 上。<br/>
噗，我这是写的啥，我还是直接上代码吧，对不住各位了，实在写不下去了，程序员嘛还是直接看代码来的最直接，对吧。
这是我的.m 文件实现代码</p>

<pre> <code> 
- (instancetype)initWithFrame:(CGRect)frame titleArr:(NSArray *)titleArr {
    self = [super initWithFrame:frame];
    size = [UIScreen mainScreen].bounds.size;
    [self setBackgroundColor:[UIColor colorWithWhite:0.5 alpha:0.5]];
    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hiddenSheet)];
    [self addGestureRecognizer:tap];
    [self makeBaseUIWithTitleArr:titleArr];
    
    return self;
}

- (void)makeBaseUIWithTitleArr:(NSArray *)titleArr{
   
    self.bgkView = [[UIView alloc] initWithFrame:CGRectMake(0, size.height, size.width, titleArr.count * 50 + 55)];
    _bgkView.backgroundColor = [UIColor colorWithRed:0xe9/255.0 green:0xe9/255.0 blue:0xe9/255.0 alpha:1.0];
    [self addSubview:_bgkView];

    CGFloat y = [self createBtnWithTitle:@"取消" origin_y: _bgkView.frame.size.height - 50 tag:-1 action:@selector(hiddenSheet)] - 55;
    for (int i = 0; i < titleArr.count; i++) {
        y = [self createBtnWithTitle:titleArr[i] origin_y:y tag:i action:@selector(click:)];
    }
    [UIView animateWithDuration:0.3 animations:^{
        CGRect frame = _bgkView.frame;
        frame.origin.y -= frame.size.height;
        _bgkView.frame = frame;
    }];
   
}

- (CGFloat)createBtnWithTitle:(NSString *)title origin_y:(CGFloat)y tag:(NSInteger)tag action:(SEL)method {
    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];
    [btn setTitle:title forState:UIControlStateNormal];
    btn.frame = CGRectMake(0, y, size.width, 50);
    btn.backgroundColor = [UIColor whiteColor];
    btn.tag = tag;
    [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    [btn addTarget:self action:method forControlEvents:UIControlEventTouchUpInside];
    [_bgkView addSubview:btn];
    return y -= tag == -1 ? 0 : 50.4;
}
- (void)hiddenSheet {
    [UIView animateWithDuration:0.3 animations:^{
        CGRect frame = _bgkView.frame;
        frame.origin.y += frame.size.height;
        _bgkView.frame = frame;
    }];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [self removeFromSuperview];
    });
}

- (void)click:(UIButton *)btn {
    if (self.Click) {
        _Click(btn.tag);
    }
}

</code> </pre>


<p></p>

<p>这是.h 文件代码</p>

<pre> <code> 
@property (nonatomic, copy) void (^Click)(NSInteger clickIndex);
- (instancetype)initWithFrame:(CGRect)frame titleArr:(NSArray *)titleArr;
- (void)hiddenSheet;

</code></pre>


<p></p>

<p>看吧，这多简单方便，有代码直接上，废话少说，程序员对代码的情结不容小觑，哼哈哈。</p>

<p>这里我也把使用的代码给贴出来吧，慢慢观察，仔细看，哈哈，使用起来很容易</p>

<pre> <code>
- (IBAction)showSheet:(id)sender {
    AS_Sheet *a = [[AS_Sheet alloc] initWithFrame:self.view.bounds titleArr:@[@"从手机相册选择", @"拍照", @"小视频"]];
    __weak typeof(a) weakA = a;
    a.Click = ^(NSInteger clickIndex) {
        switch (clickIndex) {
            case 0:
                NSLog(@"相册选择");
                break;
            case 1:
                NSLog(@"拍照");
                break;
            case 2:
                NSLog(@"小视频");
                break;
            default:
                break;
        }
        [weakA hiddenSheet];
    };
    [self.navigationController.view addSubview:a];
}

</code></pre>


<p></p>

<p>最后，老规矩我还是把<a href="https://github.com/Ashen-Zhao/ASSheet">Demo附上</a>，以供辅助参考，Demo中包含swift版本和OC版本</p>
]]></content>
  </entry>
  
</feed>
